# -*- coding: utf-8 -*-
"""Final Project - Josh Dominiack.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-rU2QTUNGf-VLKYIASwPW0LWjBlwx8mc

# ME314 FINAL PROJECT [LINK TO COLAB](https://colab.research.google.com/drive/1-rU2QTUNGf-VLKYIASwPW0LWjBlwx8mc?usp=sharing)
"""

def hat(w):
  wHat = sym.Matrix([
    [      0, -w[2,0], w[1,0]],
    [ w[2,0],       0, -w[0,0]],
    [-w[1,0],  w[0,0], 0.]
  ])

  return wHat

def unHat(wHat):
  hat = sym.Matrix([
      [wHat[2,1]],
      [wHat[0,1]],
      [wHat[1,0]]
  ])
  return hat

def inverseMat(mat):
  R = mat[0:3, 0:3]
  pInverse = -(R.T * mat[0:3, 3])

  inverseMat = sym.Matrix([
      [R.T, pInverse],
      [0, 0, 0, 1]

  ])

  return inverseMat

def Rdot(g, wHat):
  R = g[0:3, 0:3]
  return R*wHat

def pdot(g):
  p = g[0:3, 3]
  return p.diff(t)

def integrate(f, xt, dt):
    k1 = dt * f(xt)
    k2 = dt * f(xt+k1/2.)
    k3 = dt * f(xt+k2/2.)
    k4 = dt * f(xt+k3)
    new_xt = xt + (1/6.) * (k1+2.0*k2+2.0*k3+k4)
    return new_xt

import sympy as sym
import numpy as np

t, g, Lb, Lj, m, M, Jb, Jj, lam = sym.symbols(r't, g, L_b, L_j, m, M, J_b, J_j, \lambda')

xB = sym.Function('x_B')(t)
yB = sym.Function('y_B')(t)
thB = sym.Function('\theta_B')(t)

xJ = sym.Function('x_J')(t)
yJ = sym.Function('y_J')(t)
thJ = sym.Function('\theta_J')(t)

thBdot = thB.diff(t)
thJdot = thJ.diff(t)

q = sym.Matrix([xB, yB, thB, xJ, yJ, thJ])
qdot = q.diff(t)
qddot = qdot.diff(t)

#Rigid body transformations
g_wa = sym.Matrix([
    [1., 0., 0., xB],
    [0., 1., 0., yB],
    [0., 0., 1., 0.],
    [0., 0., 0., 1.]
 ])

g_ab = sym.Matrix([
    [sym.cos(thB), -sym.sin(thB), 0., 0.],
    [sym.sin(thB),  sym.cos(thB), 0., 0.],
    [          0.,            0., 1., 0.],
    [          0.,            0., 0., 1.]
 ])

g_wc = sym.Matrix([
    [1., 0., 0., xJ],
    [0., 1., 0., yJ],
    [0., 0., 1., 0.],
    [0., 0., 0., 1.]
 ])

g_cd = sym.Matrix([
    [sym.cos(thJ), -sym.sin(thJ), 0., 0.],
    [sym.sin(thJ),  sym.cos(thJ), 0., 0.],
    [          0.,            0., 1., 0.],
    [          0.,            0., 0., 1.]
 ])

g_dj1 = sym.Matrix([
    [1., 0., 0., 0.],
    [0., 1., 0., -Lj],
    [0., 0., 1., 0.],
    [0., 0., 0., 1.]
 ])

g_dj2 = sym.Matrix([
    [1., 0., 0., -Lj],
    [0., 1., 0., 0.],
    [0., 0., 1., 0.],
    [0., 0., 0., 1.]
])

g_dj3 = sym.Matrix([
    [1., 0., 0., 0.],
    [0., 1., 0., Lj],
    [0., 0., 1., 0.],
    [0., 0., 0., 1.]
])

g_dj4 = sym.Matrix([
    [1., 0., 0., Lj],
    [0., 1., 0., 0.],
    [0., 0., 1., 0.],
    [0., 0., 0., 1.]
])

g_wb = g_wa * g_ab #World to box frame transformation

g_wd = g_wc * g_cd #World to jack frame transformation

g_wj1 = g_wd * g_dj1 #World to jack end 1 transformation

g_wj2 = g_wd * g_dj2 #World to jack end 1 transformation

g_wj3 = g_wd * g_dj3 #World to jack end 1 transformation

g_wj4 = g_wd * g_dj4 #World to jack end 1 transformation

wJ = sym.Matrix([
    [0],
    [0],
    [thJdot]
])

wB = sym.Matrix([
    [0],
    [0],
    [thBdot]
])

wJHat = hat(wJ)
wBHat = hat(wB)

g_wbInv = inverseMat(g_wb)

RBdot = Rdot(g_wb, wBHat)
pBdot = pdot(g_wb)

g_wbDot = sym.Matrix([
    [RBdot, pBdot],
    [0, 0, 0, 0]
])

VbB = sym.Matrix([
    [(g_wbInv*g_wbDot)[0:3, 3]],
    [unHat((g_wbInv*g_wbDot))]
])

g_wdInv = inverseMat(g_wd)

RJdot = Rdot(g_wd, wJHat)
pJdot = pdot(g_wd)

g_wdDot = sym.Matrix([
    [RJdot, pJdot],
    [0, 0, 0, 0]
])

VbJ = sym.Matrix([
    [(g_wdInv*g_wdDot)[0:3, 3]],
    [unHat((g_wdInv*g_wdDot))]
])

zeroVec = sym.Matrix([[0], [0], [0], [0], [0]])

K1 = 0.5 * VbB.T * sym.Matrix([[m*sym.eye(5), zeroVec], [zeroVec.T, sym.Matrix([Jb])]])*VbB
K2 = 0.5 * VbJ.T * sym.Matrix([[m*sym.eye(5), zeroVec], [zeroVec.T, sym.Matrix([Jj])]])*VbJ
K = K1+K2

U = M*g*yB + m*g*yJ
L = K[0,0] - U

dLdqdot = L.diff(qdot)
dLdqdot = sym.simplify(dLdqdot)

lhs1 = L.diff(qdot[0]).diff(t) - L.diff(q[0])
lhs2 = L.diff(qdot[1]).diff(t) - L.diff(q[1])
lhs3 = L.diff(qdot[2]).diff(t) - L.diff(q[2])
lhs4 = L.diff(qdot[3]).diff(t) - L.diff(q[3])
lhs5 = L.diff(qdot[4]).diff(t) - L.diff(q[4])
lhs6 = L.diff(qdot[5]).diff(t) - L.diff(q[5])
lhs = sym.Matrix([lhs1, lhs2, lhs3, lhs4, lhs5, lhs6])

Fx = -q[0] *50
Fy = M*g + -(q[1]-5)*50

rhs1 = Fx
rhs2 = Fy
rhs3 = 0
rhs4 = 0
rhs5 = 0
rhs6 = 0
rhs = sym.Matrix([rhs1, rhs2, rhs3, rhs4, rhs5, rhs6])

eq_subs = {m:0.5, M:40, g:9.8, Jj:1, Jb:10, Lb:5, Lj:1}

el_eqns = sym.Eq(sym.simplify(lhs), sym.simplify(rhs))
el_eqns = el_eqns.subs(eq_subs)
el_soln = sym.solve(el_eqns, qddot)

xBddot_soln = (el_soln[qddot[0]].simplify())
yBddot_soln = (el_soln[qddot[1]].simplify())
thBddot_soln = (el_soln[qddot[2]].simplify())
xJddot_soln = (el_soln[qddot[3]].simplify())
yJddot_soln = (el_soln[qddot[4]].simplify())
thJddot_soln = (el_soln[qddot[5]].simplify())

xBddot_func = sym.lambdify([q[0], q[1], q[2], q[3], q[4], q[5], qdot[0], qdot[1], qdot[2], qdot[3], qdot[4], qdot[5]], xBddot_soln)
yBddot_func = sym.lambdify([q[0], q[1], q[2], q[3], q[4], q[5], qdot[0], qdot[1], qdot[2], qdot[3], qdot[4], qdot[5]], yBddot_soln)
thBddot_func = sym.lambdify([q[0], q[1], q[2], q[3], q[4], q[5], qdot[0], qdot[1], qdot[2], qdot[3], qdot[4], qdot[5]], thBddot_soln)
xJddot_func = sym.lambdify([q[0], q[1], q[2], q[3], q[4], q[5], qdot[0], qdot[1], qdot[2], qdot[3], qdot[4], qdot[5]], xJddot_soln)
yJddot_func = sym.lambdify([q[0], q[1], q[2], q[3], q[4], q[5], qdot[0], qdot[1], qdot[2], qdot[3], qdot[4], qdot[5]], yJddot_soln)
thJddot_func = sym.lambdify([q[0], q[1], q[2], q[3], q[4], q[5], qdot[0], qdot[1], qdot[2], qdot[3], qdot[4], qdot[5]], thJddot_soln)

def dyn(s):
  return np.array([s[6], s[7], s[8], s[9], s[10], s[11], xBddot_func(*s), yBddot_func(*s), thBddot_func(*s), xJddot_func(*s), yJddot_func(*s), thJddot_func(*s)])

def rb(g, coord): #Returns the coordinates of a jack point in the b frame
  rJ = sym.Matrix([[0], [0], [0], [1]])
  g_bw = inverseMat(g_wb) #finds the inverse of the world to box frame transformation
  rb = g_bw*g*rJ #converts the jack frame origin to the world frame and then to the b frame
  if coord == 'x':
    return rb[0,0]
  if coord == 'y':
    return rb[1,0]

#Phi impact conditions:
phi11 = rb(g_wj1, 'y') - -Lb/2
phi12 = rb(g_wj1, 'x') - -Lb/2
phi13 = rb(g_wj1, 'y') - Lb/2
phi14 = rb(g_wj1, 'x') - Lb/2

phi21 = rb(g_wj2, 'y') - -Lb/2
phi22 = rb(g_wj2, 'x') - -Lb/2
phi23 = rb(g_wj2, 'y') - Lb/2
phi24 = rb(g_wj2, 'x') - Lb/2

phi31 = rb(g_wj3, 'y') - -Lb/2
phi32 = rb(g_wj3, 'x') - -Lb/2
phi33 = rb(g_wj3, 'y') - Lb/2
phi34 = rb(g_wj3, 'x') - Lb/2

phi41 = rb(g_wj4, 'y') - -Lb/2
phi42 = rb(g_wj4, 'x') - -Lb/2
phi43 = rb(g_wj4, 'y') - Lb/2
phi44 = rb(g_wj4, 'x') - Lb/2

phiList = [phi11, phi12, phi13, phi14, phi21, phi22, phi23, phi24, phi31, phi32, phi33, phi34, phi41, phi42, phi43, phi44]

L = sym.Matrix([L])
H = L[0,0].diff(qdot).T * qdot - L
H = sym.simplify(H)

dthB, dthJ = sym.symbols(r'\theta_B, \theta_J')
dthBdot, dthJdot = sym.symbols(r'\dot{\theta}_B, \dot{\theta}_J')
dthBddot, dthJddot = sym.symbols(r'\ddot{\theta}_B, \ddot{\theta}_J')

dumxB, dumyB = sym.symbols(r'x_B, y_B')
dumxBdot, dumyBdot = sym.symbols(r'dot{x}_B, dot{y}_B')
dumxBddot, dumyBddot = sym.symbols(r'ddot{x}_B, ddot{y}_B')

dumxJ, dumyJ = sym.symbols(r'x_J, y_J')
dumxJdot, dumyJdot = sym.symbols(r'dot{x}_J, dot{y}_J')
dumxJddot, dumyJddot = sym.symbols(r'ddot{x}_J, ddot{y}_J')


dummy_dict = {q[0]: dumxB, q[1]: dumyB, q[2]:dthB, q[3]: dumxJ, q[4]: dumyJ, q[5]: dthJ,
              qdot[0]: dumxBdot, qdot[1]: dumyBdot, qdot[2]:dthBdot, qdot[3]: dumxJdot, qdot[4]: dumyJdot, qdot[5]: dthJdot,
              qddot[0]: dumxBddot, qddot[1]: dumyBddot, qddot[2]:dthBddot, qddot[3]: dumxJddot, qddot[4]: dumyJddot, qddot[5]: dthJddot,}


xBdotPlus, yBdotPlus, thBdotPlus, xJdotPlus, yJdotPlus, thJdotPlus = sym.symbols(r'\dot{x}_{B+}, \dot{y}_{B+}, \dot{\theta}_{B+}, \dot{x}_{J+}, \dot{y}_{J+}, \dot{\theta}_{J+} ')
impact_dict = {dumxBdot: xBdotPlus, dumyBdot: yBdotPlus, dthBdot: thBdotPlus, dumxJdot: xJdotPlus, dumyJdot: yJdotPlus, dthJdot: thJdotPlus}


dLdqdot_Sym = dLdqdot.subs(dummy_dict)

H_Sym = H.subs(dummy_dict)

dLdqdot_SymPlus = dLdqdot_Sym.subs(impact_dict)
dLdqdot_SymPlus = sym.simplify(dLdqdot_SymPlus)

H_SymPlus = H_Sym.subs(impact_dict)
H_SymPlus = sym.simplify(H_SymPlus)

#Impact update equations:
lhs1 = dLdqdot_SymPlus[0] - dLdqdot_Sym[0]
lhs2 = dLdqdot_SymPlus[1] - dLdqdot_Sym[1]
lhs3 = dLdqdot_SymPlus[2] - dLdqdot_Sym[2]
lhs4 = dLdqdot_SymPlus[3] - dLdqdot_Sym[3]
lhs5 = dLdqdot_SymPlus[4] - dLdqdot_Sym[4]
lhs6 = dLdqdot_SymPlus[5] - dLdqdot_Sym[5]
lhs7 = H_SymPlus - H_Sym
lhs = sym.Matrix([lhs1, lhs2, lhs3, lhs4, lhs5, lhs6, lhs7])

def impact_eqn_gen(phi): #Generates the rest of the impact eqs given the phi condition
  dphidq = phi.diff(q)

  dphidq_Sym = dphidq.subs(dummy_dict)
  dphidq_SymPlus = dphidq_Sym.subs(impact_dict)
  dphidq_SymPlus = sym.simplify(dphidq_SymPlus)

  rhs1 = lam * dphidq_Sym[0]
  rhs2 = lam * dphidq_Sym[1]
  rhs3 = lam * dphidq_Sym[2]
  rhs4 = lam * dphidq_Sym[3]
  rhs5 = lam * dphidq_Sym[4]
  rhs6 = lam * dphidq_Sym[5]
  rhs7 = 0

  rhs = sym.Matrix([rhs1, rhs2, rhs3, rhs4, rhs5, rhs6, rhs7])

  impact_eqns = sym.Eq(lhs, rhs)
  impact_eqns = sym.simplify(impact_eqns)
  impact_eqns = impact_eqns.subs(eq_subs)

  return impact_eqns


def impact_condition(s, phi, threshold=1e-1):
  phiTest = ((phi.subs({q[0]:s[0], q[1]:s[1], q[2]:s[2], q[3]:s[3], q[4]:s[4], q[5]:s[5]})))
  phiTest = phiTest.subs(eq_subs)

  if (phiTest > -threshold and phiTest < threshold):
    return True
  else:
    return False

def impact_update(s, impact_eqns):
  subs_dict = {dumxB: s[0], dumyB: s[1], dthB: s[2], dumxJ: s[3], dumyJ: s[4], dthJ: s[5],
               dumxBdot: s[6], dumyBdot:s[7], dthBdot: s[8], dumxJdot: s[9], dumyJdot: s[10], dthJdot: s[11]}
  new_impact_eqns = impact_eqns.subs(subs_dict)

  impact_solns = sym.solve(new_impact_eqns, [xBdotPlus, yBdotPlus, thBdotPlus, xJdotPlus, yJdotPlus, thJdotPlus, lam])

  if len(impact_solns) == 1:
    print("Only one solution :(")
  else:
    for sol in impact_solns:
      lam_sol = sol[6]
      if abs(lam_sol) < 1e-06:
        pass
      else:
        return np.array([
            s[0],
            s[1],
            s[2],
            s[3],
            s[4],
            s[5],
            float(sym.N(sol[0])),
            float(sym.N(sol[1])),
            float(sym.N(sol[2])),
            float(sym.N(sol[3])),
            float(sym.N(sol[4])),
            float(sym.N(sol[5]))
        ])

def impact_simulate(f, x0, tspan, dt, integrate):
    N = int((max(tspan)-min(tspan))/dt)
    x = np.copy(x0)
    tvec = np.linspace(min(tspan),max(tspan),N)
    xtraj = np.zeros((len(x0),N))
    for i in range(N):
      activePhi = None
      for phi in phiList: #Iterates through phi conditions
        if impact_condition(x, phi) is True:
          activePhi = phi #records which phi condition is zero (where the impact is)
          break

      if activePhi is not None: #Switches to the impact update eqs if there is impact
        x = impact_update(x, impact_eqn_gen(activePhi))
        xtraj[:,i] = integrate(f,x,dt)
      else:
        xtraj[:,i] = integrate(f,x,dt) #Uses regular euler-lagrange equations
      x = np.copy(xtraj[:,i])
    return xtraj

#Initial conditions
s0 = np.array([0, 5, 0, 0, 5, 0, 4, 10, -1, 1, -10, 2])

traj = impact_simulate(dyn, s0, [0,10], 0.01, integrate)

def animate(array,Ljack=1, Lbox=5, T=10):
    ################################
    # Imports required for animation.
    from plotly.offline import init_notebook_mode, iplot
    from IPython.display import display, HTML
    import plotly.graph_objects as go

    #######################
    # Browser configuration.
    def configure_plotly_browser_state():
        import IPython
        display(IPython.core.display.HTML('''
            <script src="/static/components/requirejs/require.js"></script>
            <script>
              requirejs.config({
                paths: {
                  base: '/static/base',
                  plotly: 'https://cdn.plot.ly/plotly-1.5.1.min.js?noext',
                },
              });
            </script>
            '''))
    configure_plotly_browser_state()
    init_notebook_mode(connected=False)

    N = len(array[0]) # Need this for specifying length of simulation

    xB_array = array[0]
    yB_array = array[1]
    thB_array = array[2]
    xJ_array = array[3]
    yJ_array = array[4]
    thJ_array = array[5]

    box_pt12_x_array = np.zeros(N, dtype=np.float32)
    box_pt12_y_array = np.zeros(N, dtype=np.float32)
    box_pt23_x_array = np.zeros(N, dtype=np.float32)
    box_pt23_y_array = np.zeros(N, dtype=np.float32)
    box_pt34_x_array = np.zeros(N, dtype=np.float32)
    box_pt34_y_array = np.zeros(N, dtype=np.float32)
    box_pt41_x_array = np.zeros(N, dtype=np.float32)
    box_pt41_y_array = np.zeros(N, dtype=np.float32)

    jack_pt1_x_array = np.zeros(N, dtype=np.float32)
    jack_pt1_y_array = np.zeros(N, dtype=np.float32)
    jack_pt2_x_array = np.zeros(N, dtype=np.float32)
    jack_pt2_y_array = np.zeros(N, dtype=np.float32)
    jack_pt3_x_array = np.zeros(N, dtype=np.float32)
    jack_pt3_y_array = np.zeros(N, dtype=np.float32)
    jack_pt4_x_array = np.zeros(N, dtype=np.float32)
    jack_pt4_y_array = np.zeros(N, dtype=np.float32)


    for t in range(N): # iteration through each time step

      g_wa_np = np.array([
          [1., 0., 0., xB_array[t]],
          [0., 1., 0., yB_array[t]],
          [0., 0., 1., 0.],
          [0., 0., 0., 1.]
      ])

      g_ab_np = np.array([
          [np.cos(thB_array[t]), -np.sin(thB_array[t]), 0., 0.],
          [np.sin(thB_array[t]),  np.cos(thB_array[t]), 0., 0.],
          [          0.,            0., 1., 0.],
          [          0.,            0., 0., 1.]
      ])

      g_wc_np = np.array([
          [1., 0., 0., xJ_array[t]],
          [0., 1., 0., yJ_array[t]],
          [0., 0., 1., 0.],
          [0., 0., 0., 1.]
      ])

      g_cd_np = np.array([
          [np.cos(thJ_array[t]), -np.sin(thJ_array[t]), 0., 0.],
          [np.sin(thJ_array[t]),  np.cos(thJ_array[t]), 0., 0.],
          [          0.,            0., 1., 0.],
          [          0.,            0., 0., 1.]
      ])

      g_wb_np = g_wa_np.dot(g_ab_np)

      g_wd_np = g_wc_np.dot(g_cd_np)

      box_pt12 = g_wb_np.dot(np.array([-Lbox/2., -Lbox/2., 0., 1.]))
      box_pt12_x_array[t] = box_pt12[0]
      box_pt12_y_array[t] = box_pt12[1]

      box_pt23 = g_wb_np.dot(np.array([-Lbox/2., Lbox/2., 0., 1.]))
      box_pt23_x_array[t] = box_pt23[0]
      box_pt23_y_array[t] = box_pt23[1]

      box_pt34 = g_wb_np.dot(np.array([Lbox/2., Lbox/2., 0., 1.]))
      box_pt34_x_array[t] = box_pt34[0]
      box_pt34_y_array[t] = box_pt34[1]

      box_pt41 = g_wb_np.dot(np.array([Lbox/2., -Lbox/2., 0., 1.]))
      box_pt41_x_array[t] = box_pt41[0]
      box_pt41_y_array[t] = box_pt41[1]


      jack_pt1 = g_wd_np.dot(np.array([0., -Ljack, 0., 1.]))
      jack_pt1_x_array[t] = jack_pt1[0]
      jack_pt1_y_array[t] = jack_pt1[1]

      jack_pt2 = g_wd_np.dot(np.array([-Ljack, 0., 0., 1.]))
      jack_pt2_x_array[t] = jack_pt2[0]
      jack_pt2_y_array[t] = jack_pt2[1]

      jack_pt3 = g_wd_np.dot(np.array([0., Ljack, 0., 1.]))
      jack_pt3_x_array[t] = jack_pt3[0]
      jack_pt3_y_array[t] = jack_pt3[1]

      jack_pt4 = g_wd_np.dot(np.array([Ljack, 0, 0., 1.]))
      jack_pt4_x_array[t] = jack_pt4[0]
      jack_pt4_y_array[t] = jack_pt4[1]

    ####################################
    # Using these to specify axis limits.
    xm = -5 #np.min(xx1)-0.5
    xM = 5 #np.max(xx1)+0.5
    ym = 0 #np.min(yy1)-2.5
    yM = 10 #np.max(yy1)+1.5

    data=[

        dict(name='Box'),
        dict(name='Jack'),
        dict(name='Jack')
        ]

    ################################
    # Preparing simulation layout.
    # Title and axis ranges are here.
    layout=dict(autosize=False, width=1000, height=1000,
                xaxis=dict(range=[xm, xM], autorange=False, zeroline=False,dtick=1),
                yaxis=dict(range=[ym, yM], autorange=False, zeroline=False,scaleanchor = "x",dtick=1),
                title='Box and Jack Simulation',
                hovermode='closest',
                updatemenus= [{'type': 'buttons',
                               'buttons': [{'label': 'Play','method': 'animate',
                                            'args': [None, {'frame': {'duration': T, 'redraw': False}}]},
                                           {'args': [[None], {'frame': {'duration': T, 'redraw': False}, 'mode': 'immediate',
                                            'transition': {'duration': 0}}],'label': 'Pause','method': 'animate'}
                                          ]
                              }]
               )

    frames=[dict(data=[# first three objects correspond to the arms and two masses,
                       # same order as in the "data" variable defined above (thus
                       # they will be labeled in the same order)
                       dict(x=[box_pt12_x_array[k],
                               box_pt23_x_array[k],
                               box_pt34_x_array[k],
                               box_pt41_x_array[k],
                               box_pt12_x_array[k]],
                            y=[box_pt12_y_array[k],
                               box_pt23_y_array[k],
                               box_pt34_y_array[k],
                               box_pt41_y_array[k],
                               box_pt12_y_array[k]],
                            mode='lines',
                            line=dict(color='red', width=3),),
                       dict(x=[jack_pt1_x_array[k],
                               jack_pt3_x_array[k]],
                            y=[jack_pt1_y_array[k],
                               jack_pt3_y_array[k]],
                            mode='lines',
                            line=dict(color='blue', width=3),),
                       dict(x=[jack_pt2_x_array[k],
                               jack_pt4_x_array[k]],
                            y=[jack_pt2_y_array[k],
                               jack_pt4_y_array[k]],
                            mode='lines',
                            line=dict(color='blue', width=3),),
                      ]) for k in range(N)]

    figure1=dict(data=data, layout=layout, frames=frames)
    iplot(figure1)

animate(traj)